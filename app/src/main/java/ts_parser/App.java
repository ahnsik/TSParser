/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package ts_parser;

import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.IOException;

public class App {
    private static tsPacketCollector PAT;
    private static short pmt_pid = 0x7FFF;              // default 값 0x7FFF는 미설정 상태.
    private static tsPacketCollector PMT;
    private static short dsmcc_addressable_pid = 0x7FFF;   // default 값 0x7FFF는 미설정 상태.
    private static tsPacketCollector DSMCC_addr;
    private static tsPacketCollector tssBuf;

    public static void main(String[] args) {
        tsPacket tsp;
        byte[] tspacket_buf = new byte[188];
        PAT = new tsPacketCollector((short)0);     // PAT PID=0
        PAT.setOnPayloadUnitCompleteListener(new PayloadUnitCompleteListener() {
            @Override
            public void onComplete(PayloadUnitComplete event) {
                byte[] patDump = PAT.getCompletedPayload();
                System.out.println("PAT received.");
                dump_byteArray(patDump);
            }
            @Override
            public void onInvalidContinuity(PayloadUnitComplete event) {
            }
        });

        if (pmt_pid!=0x7FFF) {       // PAT를 수신해서 pmt PID를 얻어 온 상태.
            PMT = new tsPacketCollector((short) pmt_pid);
            PMT.setOnPayloadUnitCompleteListener(new PayloadUnitCompleteListener() {
                @Override
                public void onComplete(PayloadUnitComplete event) {
                    byte[] pmtDump = PMT.getCompletedPayload();
                    System.out.println("PMT received.");
                    dump_byteArray(pmtDump);
                }
                @Override
                public void onInvalidContinuity(PayloadUnitComplete event) {
                }
            });
        }

        if (dsmcc_addressable_pid!=0x7FFF) {
            DSMCC_addr = new tsPacketCollector(dsmcc_addressable_pid);
            DSMCC_addr.setOnPayloadUnitCompleteListener(new PayloadUnitCompleteListener() {
                @Override
                public void onComplete(PayloadUnitComplete event) {
                    byte[] dsmccAddr_Dump = DSMCC_addr.getCompletedPayload();
                    System.out.println("PMT received.");
                    dump_byteArray(dsmccAddr_Dump);
                }
                @Override
                public void onInvalidContinuity(PayloadUnitComplete event) {
                }
            });
        }

        tssBuf = new tsPacketCollector((short)0x101);
        tssBuf.setOnPayloadUnitCompleteListener(new PayloadUnitCompleteListener() {
            @Override
            public void onComplete(PayloadUnitComplete event) {
                byte[] payloadDump = tssBuf.getCompletedPayload();
                if (payloadDump != null) {
                    System.out.println(">>>>>> read TS Packet Dump. <<<<<<------>>>>>>");
                    for (int i=0; i<payloadDump.length; i++) {
                        System.out.printf( "%02X,", payloadDump[i] );
                        if (i%20==19)
                            System.out.printf("\n");
                    }
                    System.out.println("------");
                }
            }

            @Override
            public void onInvalidContinuity(PayloadUnitComplete event) {
                System.out.printf( "뭔가 잘못됐음. " );
            }
        } );

        int read_bytes = 0;
        try {
            FileInputStream in = new FileInputStream("C:\\Users\\happy\\Downloads\\ts-sample-video\\ts.ts");
//            FileInputStream in = new FileInputStream(args[1]);

            do {
                read_bytes = in.read(tspacket_buf);
                System.out.println("\n\n------ read TS Packet Dump. ------");
                for (int i=0; i<tspacket_buf.length; i++) {
                    System.out.printf( "%02X ", tspacket_buf[i] );
                    if (i%30==29)
                        System.out.printf("\n");
                }
                System.out.println("------");
                tsp = new tsPacket(tspacket_buf);
                if (tsp.getTsErrorIndicator()) {
                    System.out.printf("\nTS Packet has Error !!: transport error indicator is %s", tsp.getTsErrorIndicator() ? "set" : "un-set");
                } else {
                    System.out.printf("\nTS Packet: PID=0x%X, %s", tsp.getPID(), tsp.getPUSI() ? "has New Section" : "append payload");
                    System.out.printf("\n         : tsPriority= %s, scrambled=%d", tsp.getTsPriority() ? "true" : "false", tsp.getTsScramblingControl());
                    System.out.printf("\n         : adaptation= %s(%d), continuity counter=%d", (tsp.getAdaptationFieldControl() == 2) ? "adaptation field only. no payload." : (tsp.getAdaptationFieldControl() == 3) ? "adaptation field exist also payload." : (tsp.getAdaptationFieldControl() == 1) ? "No Adaption Field, only payload" : "Reserved for future. actually has some errors.",
                            tsp.getAdaptationFieldControl(), tsp.getContinuityCounter());
                    System.out.printf("\n         : adaptationFieldLength= %d", tsp.getAdaptationFieldLength());
                    tssBuf.append_packet(tsp);
/*                    if (tsp.getPUSI()) {
                        System.out.println("\n---- old section_remained:");
                        byte[] old = tsp.getPayload();
                        if (old != null) {
                            for (int i = 0; i < old.length; i++) {
                                System.out.printf("%02X,", old[i]);
                            }
                        }
                        System.out.println("------");
                        byte[] newSectionPayload = tsp.getNewSectionPayload();
                        for (int i = 0; i < newSectionPayload.length; i++) {
                            System.out.printf("0x%02X,", newSectionPayload[i]);
                        }
                        System.out.println("------");
                    } else {
                        System.out.println("\n---- need to append to section.");
                        byte[] old = tsp.getPayload();
                        for (int i = 0; i < old.length; i++) {
                            System.out.printf("%02X ", old[i]);
                        }
                        System.out.println("------");
                    }   */
                }

            } while (read_bytes>=188);

        } catch (FileNotFoundException e) {
            System.out.println("File not found.");
            throw new RuntimeException(e);
        } catch (IOException e) {
            System.out.println("READ failed.");
            throw new RuntimeException(e);
        }
    }


/*
    만약 buffer 가 TS 패킷 버퍼가 아니거나, 188바이트 단위로 정렬되지 않은 상태라면,
    TS버퍼의 시작점 (0x47)을 찾는다.
    - 그런데 현재의 test code 는 file 로 부터 읽어서 미리 파일로 부터 읽어 버리면 align 하기
    쉽지 않다.  InputStreaming 으로 들어오는 건 모두 같은 형태이므로 실제로는 별로 사용성이 없을 것 같지만...
***
    public static int getAlignedStart(byte[] buff) {
        int offset = 0;
        // 버퍼 에서, 0x47 을 찾는다
        while(buff[offset] != 0x47) {
            offset++;
        }
        // 그 다음 188 바이트 뒤에 또다시 0x47이 오는지, (*4번반복) 확인
        while (offset <= (buff.length-188) ) {
            if ( (buff[offset]==0x47)&&(buff[offset+188]==0x47)&&(buff[offset+188+188]==0x47)&&(buff[offset+188+188+188]==0x47) ) {
                break;
            }
            offset++;
        }
        return offset;
    }
 */

    public static void dump_byteArray(byte[] payload) {
        System.out.println(">>>>>>>>>> Dump payloads <<<<<<<<<");
        for (int i=0; i<payload.length; i++) {
            System.out.printf( "%02X,", payload[i] );
            if (i%30==29)
                System.out.printf("\n");
        }
        System.out.println("\n>>>>>>>>>>> end of DUMP <<<<<<<<<<<");
    }
}
